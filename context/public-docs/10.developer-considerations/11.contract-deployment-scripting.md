---
title: Contract Deployment and Scripting
description:
  Considerations and patterns for deploying smart contracts and scripting interactions with Prividium™ chains.
downloadable: true
---

Learn how to deploy smart contracts and write scripts that interact with Prividium™ chains.

> [!NOTE] Architecture Overview
>
> For a high-level understanding of Prividium's architecture and components, see
> [Prividium™ Architecture](../00.prividium_architecture.md).

## Table of Contents

1. [Obtaining Authentication Tokens (SIWE Flow)](/docs/developer-considerations/programmatic-token-management)
1. [Scripting with Viem and Ethers](#scripting-with-viem-and-ethers)
1. [Deploying Smart Contracts](#deploying-smart-contracts)
1. [Configuring Contract Method Permissions](#configuring-contract-method-permissions)
1. [Next Steps](#next-steps)

## Overview

Prividium™ chains enforce authentication on all RPC interactions. Unlike public blockchains where anyone can read state
or submit transactions, Prividium™ requires valid JWT tokens for both read and write operations.

Scripting libraries (Ethers, Viem) support custom HTTP headers, so you can add authentication tokens to requests. This
works for deployment scripts, backend services, and test suites.

This guide covers:

- Obtaining authentication tokens via the SIWE (Sign-In With Ethereum) flow
- Configuring Ethers and Viem to use authenticated RPC endpoints
- Three deployment methods for smart contracts
- Configuring contract permissions after deployment

## Obtaining Authentication Tokens (SIWE Flow)

The first stop is to get a valid token. You can follow
[this guide](/docs/developer-considerations/programmatic-token-management) to programmatically get and refresh valid
tokens.

> [!IMPORTANT] IMPORTANT
>
> Your account must have permissions to interact with the Prividium™ chain. Contact your network administrator to
> request access.

Once you have a valid auth token, you can use it to interact with your Prividium™ chain.

## Scripting with Viem and Ethers

Scripting tools inject custom headers into HTTP requests, enabling direct access to the Prividium™ RPC endpoint via
token-based authentication (`Authorization: Bearer {token}` headers).

Use scripts for:

- Backend services
- Contract deployments
- Automated transactions

> [!NOTE] NOTE
>
> Learn how to obtain authentication tokens in the
> [Authentication Tokens](/docs/developer-considerations/programmatic-token-management) doc.

### Ethers Scripts

Ethers v6.x uses the `FetchRequest` class for custom headers:

```typescript
import { ethers, FetchRequest } from 'ethers';

// Get authentication token (from API)
const authToken = await getAuthToken();

// Create FetchRequest with auth header
const fetchRequest = new FetchRequest(rpcUrl);
fetchRequest.setHeader('Authorization', `Bearer ${authToken}`);

// Create provider with FetchRequest
const provider = new ethers.JsonRpcProvider(fetchRequest);

// Example: Get account balance
const address = '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb';
const balance = await provider.getBalance(address);
console.log(`Balance: ${ethers.formatEther(balance)} ETH`);
```

### Viem Scripts

Viem's `http` transport accepts custom headers via `fetchOptions`:

```typescript
import { http, createPublicClient, formatEther } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';

// Get authentication token (from API)
const authToken = await getAuthToken();

// Create transport with auth headers
const transport = http(rpcUrl, {
  fetchOptions: {
    headers: {
      Authorization: `Bearer ${authToken}`
    }
  }
});

// Create public client for read operations
const publicClient = createPublicClient({
  chain: prividiumChain,
  transport
});

// Example: Get account balance
const address = '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb';
const balance = await publicClient.getBalance({ address });
console.log(`Balance: ${formatEther(balance)} ETH`);
```

## Deploying Smart Contracts

### Prerequisites

Contract deployment requires:

- User account with deployment permissions
- [Authentication token](/docs/developer-considerations/programmatic-token-management)

Deployment attempts without these permissions fail with an error.

> [!IMPORTANT] IMPORTANT
>
> Contact your network administrator to request deployment permissions.

### Deployment Options

Choose one of three deployment methods:

#### Option 1: Use the Prividium™ Local Proxy

The [Prividium™ NPM package](https://www.npmjs.com/package/prividium) provides a CLI tool that runs a local proxy. The
proxy automatically injects authentication headers into your RPC requests.

**Steps:**

1. Start the local proxy with the following command:

   ```bash
   npx prividium proxy \
     -r https://proxy.prividium.dev/ \
     -u https://user-panel.prividium.dev/
   ```

   Flags:
   - `-r`: Prividium™ proxy RPC URL
   - `-u`: User panel URL

2. The proxy will:
   - Open the user panel in your browser
   - Prompt for authentication
   - Store your access token
   - Start a local proxy server

3. Deploy contracts using the local endpoint. The proxy injects authentication headers and forwards requests to the
   Prividium™ RPC.

**Example usage:**

```bash
# After starting the proxy, use the local endpoint
forge script DeployScript \
  --rpc-url http://127.0.0.1:24101/rpc \
  --broadcast
```

#### Option 2: Handle Auth Token Manually in JavaScript/TypeScript

Obtain authentication tokens by calling the Prividium™ API directly with crypto-native authentication (SIWE).

**Steps:**

1. Retrieve authentication token by calling the Prividium™ API
   [as detailed here](/docs/developer-considerations/programmatic-token-management).

2. Inject the token in your deployment script using ethers or viem:

**Example with Ethers:**

```typescript
import { ethers, FetchRequest } from 'ethers';
import { getAuthToken } from './utils';

async function deployContract() {
  // Step 1: Get authentication token
  const token = await getAuthToken(wallet, prividiumApiUrl);

  // Step 2: Create FetchRequest with auth header
  const fetchRequest = new FetchRequest(process.env.RPC_URL || 'https://proxy.prividium.dev/rpc');
  fetchRequest.setHeader('Authorization', `Bearer ${token}`);

  // Step 3: Create provider with authenticated FetchRequest
  const provider = new ethers.JsonRpcProvider(fetchRequest);

  // Step 4: Create signer with private key
  const signer = new ethers.Wallet(privateKey, provider);

  // Step 5: Deploy the contract
  const factory = new ethers.ContractFactory(abi, bytecode, signer);
  const contract = await factory.deploy();
  await contract.waitForDeployment();

  const contractAddress = await contract.getAddress();
  console.log(`Contract deployed at: ${contractAddress}`);

  return contractAddress;
}
```

**Example with Viem:**

```typescript
import { http, createWalletClient } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { getAuthToken } from './utils';

async function deployContract() {
  // Step 1: Get authentication token
  const token = await getAuthToken(wallet, prividiumApiUrl);

  // Step 2: Create transport with auth headers
  const transport = http(process.env.RPC_URL || 'https://proxy.prividium.dev/rpc', {
    fetchOptions: {
      headers: {
        Authorization: `Bearer ${token}`
      }
    }
  });

  // Step 3: Create account from private key
  const account = privateKeyToAccount(privateKey);

  // Step 4: Create wallet client
  const walletClient = createWalletClient({
    account,
    chain: prividiumChain,
    transport
  });

  // Step 5: Deploy the contract
  const hash = await walletClient.deployContract({
    abi,
    bytecode,
    args: []
  });

  console.log(`Contract deployment tx: ${hash}`);

  return hash;
}
```

#### Option 3: Using `cast` (Foundry)

Deploy contracts using `cast` with manual token injection.

**Steps:**

1. Write a script to call the Prividium™ API to retrieve a token for a registered wallet address
   [as detailed here](/docs/developer-considerations/programmatic-token-management).

2. Use the token with `cast`:
   ```bash
   cast send \
     --rpc-url $PRIVIDIUM_RPC_URL \
     --account YOUR-ACCOUNT \
     --headers "Authorization: Bearer $TOKEN" \
     --create "$(jq -r '.bytecode.object' out/Greeter.sol/Greeter.json)"
   ```

> [!NOTE] NOTE
>
> The `--headers` flag injects the Authorization header with your token.

## Configuring Contract Method Permissions

**All contract functions default to "Forbidden" until configured**. Chain administrators must register new contracts and
configure method permissions in the Prividium™ Admin Panel after deployment.

> [!IMPORTANT] IMPORTANT
>
> All permissions require user authentication via OIDC/JWT.

1. **Register the contract**: Provide the contract name, address, and ABI in the admin panel

2. **View Function List**: Review all functions from the contract ABI

3. **Edit Permissions**: For each function:
   - Select permission type (Forbidden, All Users, Check Role, etc.)
   - Configure role requirements (if using role-based permissions)
   - Set argument restrictions (if needed)
   - Save changes

4. **Verify Configuration**: Permissions activate immediately. Test by calling functions from your application.

> [!NOTE] NOTE
>
> Chain administrators can find more information about contract registration and permissions in the "Configuration"
> section of the Admin Panel documentation.

### Permission Enforcement

**Read Functions (`view`/`pure`)**

- Permission check occurs during `eth_call`
- Unauthorized calls return an error

**Write Functions (`nonpayable`/`payable`)**

- Permission checks occur twice:
  - Simulation phase (`eth_call` for gas estimation)
  - Execution phase (`eth_sendRawTransaction`)
- Both checks must pass for transaction success

## Next Steps

- [Building Web Applications](20.building-web-applications.md) - Build frontend applications that interact with
  Prividium™ chains
- [AI Agent Guide for Prividium™](30.ai-context.md) - Guidelines for AI agents working with Prividium™

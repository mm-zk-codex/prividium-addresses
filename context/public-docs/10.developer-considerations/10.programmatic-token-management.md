---
title: Manage Auth Tokens Programmatically
description:
  Learn how to issue, check, and refresh authentication tokens using the SIWE flow for programmatic API access.
---

This guide explains how to programmatically manage authentication tokens in Prividium using Sign-In With Ethereum
(SIWE). Tokens are required for authenticated access to the Prividium API and RPC endpoints.

## Token Lifecycle Overview

1. **Issue**: Request a SIWE message, sign it with your wallet, and exchange it for a session token
2. **Check**: Query the current session endpoint to verify token validity and expiration
3. **Refresh**: When expired, repeat the SIWE flow to get a new token

## Prerequisites

You need a private key and its derived address. You can use `cast` to generate a new keypair:

```bash
$ cast wallet new
Successfully created new keypair.
Address:     0x9317a78Dc814297Defe678918A84084C427a1e59
Private key: 0xd9ad2e2da24635777b184f591ba8cf6aaf428879034030022f088a68f2390b05
```

The private key is used to sign messages. Before authenticating, the address must be associated with a user account.

To link an address to a user, log in to the Admin Panel and add the address to the user account that will be used for
programmatic access.

## Step 1: Request a SIWE Message

To get a token, first request a SIWE message from the API.

### Endpoint

```
POST /api/siwe-messages
```

### Request Body

| Field     | Type   | Required | Description                                              |
| --------- | ------ | -------- | -------------------------------------------------------- |
| `address` | string | Yes      | The wallet address (hex format, e.g., `0x...`)           |
| `domain`  | string | Yes      | Your user panel domain (i.e. `user-panel.prividium.com`) |

### Example Request

```bash
curl -X POST http://localhost:8000/api/siwe-messages \
  -H "Content-Type: application/json" \
  -d '{
    "address": "0xYourWalletAddress",
    "domain": "localhost:3000"
  }'
```

### Example Response

```json
{
  "nonce": "abc123xyz",
  "address": "0xYourWalletAddress",
  "alreadyUsed": false,
  "msg": "localhost:3000 wants you to sign in with your Ethereum account:\n0xYourWalletAddress\n\nLogin to Prividiumâ„¢ chain\n\nURI: prividium:access\nVersion: 1\nChain ID: 260\nNonce: abc123xyz\nIssued At: 2024-01-15T10:00:00.000Z\nExpiration Time: 2024-01-15T11:00:00.000Z"
}
```

## Step 2: Sign and Exchange for Token

Sign the message with your wallet and send it to the login endpoint.

### Endpoint

```
POST /api/auth/login/crypto-native
```

### Request Body

| Field       | Type   | Required | Description                       |
| ----------- | ------ | -------- | --------------------------------- |
| `message`   | string | Yes      | The SIWE message from Step 1      |
| `signature` | string | Yes      | The wallet signature (hex format) |

### Example Request

```bash
curl -X POST http://localhost:8000/api/auth/login/crypto-native \
  -H "Content-Type: application/json" \
  -d '{
    "message": "<siwe_message_from_step_1>",
    "signature": "0xYourSignature..."
  }'
```

### Example Response

```json
{
  "token": "your-session-token-here",
  "expiresAt": "2024-01-15T18:00:00.000Z"
}
```

The `token` is your session token for authenticated API calls. The `expiresAt` field indicates when the token expires.

## Step 3: Refresh Expired Tokens

When a token expires, repeat the SIWE flow (Steps 1-2) to get a new token. There is no dedicated refresh endpoint; the
full authentication flow must be repeated.

### Best Practice

Check the token expiration before each API interaction. The expiration time can be safely cached in memory, and can be
verified again at any time using the `GET /api/auth/current-session` endpoint.

1. Save expiration time locally near the token value.
2. If the token is expired or about to expire, initiate a new SIWE flow.
3. Update your stored token with the new one.

## Check Token Expiration

Verify token validity and expiration at any time using the `current-session` endpoint:

### Endpoint

```
GET /api/auth/current-session
```

### Headers

| Header          | Value                         |
| --------------- | ----------------------------- |
| `Authorization` | `Bearer <your-session-token>` |

### Example Request

```bash
curl -X GET http://localhost:8000/api/auth/current-session \
  -H "Authorization: Bearer <your-session-token>"
```

### Example Response

```json
{
  "type": "user",
  "expiresAt": "2024-01-15T18:00:00.000Z"
}
```

| Field       | Type   | Description                                  |
| ----------- | ------ | -------------------------------------------- |
| `type`      | string | Session type: `user`, `tenant`, or `service` |
| `expiresAt` | string | ISO 8601 timestamp when the token expires    |

### Response Status Codes

Prividium follows standard HTTP status code conventions for the REST API:

| Status  | Description                                                       |
| ------- | ----------------------------------------------------------------- |
| 200-299 | Success. No action required.                                      |
| 401     | Authentication invalid. Invalidate the token and re-authenticate. |
| 403     | User lacks access to the requested resource. Token remains valid. |

The JSON-RPC standard does not use HTTP 401 and 403 for authentication errors. Prividium uses custom RPC error codes
instead:

| RPC Error Code | Description                                                   |
| -------------- | ------------------------------------------------------------- |
| -32090         | Authentication failed. Re-authenticate to obtain a new token. |
| -32001         | User lacks access to the requested resource. Token is valid.  |

## Example: Complete Authentication Script

The following Node.js example demonstrates the full authentication flow and subsequent API calls.

```typescript
import { createWalletClient, http, createPublicClient } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { mainnet } from 'viem/chains';

const PRIVIDIUM_API = 'http://localhost:8000';
const PRIVATE_KEY = '0xYourPrivateKey';
const DOMAIN = 'localhost:3000';

// Current valid token used to interact with API
let currentToken: string = '';
// Expiration of current token
let tokenExpiresAt: Date = new Date(1, 1, 1);

async function authenticate() {
  const account = privateKeyToAccount(PRIVATE_KEY);

  // Step 1: Request SIWE message
  const siweResponse = await fetch(`${PRIVIDIUM_API}/api/siwe-messages`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      address: account.address,
      domain: DOMAIN
    })
  });
  const siweData = await siweResponse.json();

  // Step 2: Sign the message
  const signature = await account.signMessage({
    message: siweData.msg
  });

  // Step 3: Exchange for token
  const loginResponse = await fetch(`${PRIVIDIUM_API}/api/auth/login/crypto-native`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      message: siweData.msg,
      signature: signature
    })
  });
  const { token, expiresAt } = await loginResponse.json();

  currentToken = token;
  tokenExpiresAt = new Date(expiresAt);
}

async function callRpc(token: string, method: string, params: unknown[] = []) {
  if (new Date() > tokenExpiresAt) {
    await authenticate();
  }

  const response = await fetch(`${PRIVIDIUM_API}/rpc`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`
    },
    body: JSON.stringify({
      jsonrpc: '2.0',
      method: method,
      params: params,
      id: 1
    })
  });
  return response.json();
}

async function getMyProfile() {
  if (new Date() > tokenExpiresAt) {
    await authenticate();
  }

  const response = await fetch(`${PRIVIDIUM_API}/api/profiles/me`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${token}`
    }
  });
  return response.json();
}

async function main() {
  // Authenticate
  const authResponse = await authenticate();

  // Call RPC method
  await callRpc(token, 'eth_chainId');

  // Call REST endpoint
  await getMyProfile();
}

main().catch(console.error);
```

## Security Considerations

- **Nonce expiration**: SIWE messages expire after a configured time (default: 1 hour)
- **Single use**: Each SIWE nonce can only be used once
- **Rate limiting**: Maximum 10 unused SIWE messages per 5 minutes per user

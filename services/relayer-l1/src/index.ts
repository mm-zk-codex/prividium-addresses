import { resolve } from 'node:path';
import Database from 'better-sqlite3';
import dotenv from 'dotenv';
import { FORWARDER_FACTORY_L1_ABI, STEALTH_FORWARDER_L1_ABI } from '@prividium-poc/types';
import { loadBridgeConfig } from '@prividium-poc/config';
import { createPublicClient, createWalletClient, erc20Abi, getAddress, http } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { computeNextAttemptAt, loadSupportedTokens, toTokenAllowlist, tryAcquireInflight } from './lib.js';

dotenv.config({ path: resolve(process.cwd(), '../../infra/.env') });
const pk = process.env.RELAYER_L1_PRIVATE_KEY ?? process.env.PRIVATE_KEY_RELAYER;
const rpc = process.env.L1_RPC_URL ?? process.env.RPC_URL_SEPOLIA;
if (!pk || !rpc) throw new Error('RELAYER_L1_PRIVATE_KEY and L1_RPC_URL required');

const bridgeConfig = loadBridgeConfig();
const db = new Database(process.env.SQLITE_PATH ?? resolve(process.cwd(), '../data/poc.db'));
const supportedTokens = loadSupportedTokens(process.env.BRIDGE_CONFIG_JSON_PATH ?? resolve(process.cwd(), '../../infra/bridge-config.json'));
const tokenAllowlist = toTokenAllowlist(supportedTokens);
const account = privateKeyToAccount(pk as `0x${string}`);
const publicClient = createPublicClient({ transport: http(rpc) });
const walletClient = createWalletClient({ transport: http(rpc), account });

const defaultMintEth = BigInt(process.env.MINT_VALUE_WEI_ETH_DEFAULT ?? '2000000000000000');
const defaultMintErc20 = BigInt(process.env.MINT_VALUE_WEI_ERC20_DEFAULT ?? '3000000000000000');
const maxAttempts = Number(process.env.MAX_ATTEMPTS ?? 5);
const baseDelaySeconds = Number(process.env.BASE_DELAY_SECONDS ?? 15);
const maxDelaySeconds = Number(process.env.MAX_DELAY_SECONDS ?? 900);

function createEvent(trackingId: string, kind: 'ETH' | 'ERC20', amount: bigint, token?: string | null) {
  const now = Date.now();
  const result = db
    .prepare('INSERT INTO deposit_events(trackingId, kind, l1TokenAddress, amount, status, detectedAtL1, attempts, nextAttemptAt, stuck, createdAt) VALUES(?, ?, ?, ?, ?, ?, 0, 0, 0, ?)')
    .run(trackingId, kind, token ?? null, amount.toString(), 'detected_l1', now, now);
  return Number(result.lastInsertRowid);
}

function updateEvent(eventId: number, status: string, fields: Record<string, any> = {}) {
  const keys = Object.keys(fields);
  const set = ['status=?', ...keys.map((k) => `${k}=?`)].join(', ');
  db.prepare(`UPDATE deposit_events SET ${set} WHERE id=?`).run(status, ...keys.map((k) => fields[k]), eventId);
}

function markEventError(eventId: number, err: unknown) {
  const event = db.prepare('SELECT attempts FROM deposit_events WHERE id=?').get(eventId) as any;
  const attempts = Number(event?.attempts ?? 0) + 1;
  const now = Date.now();
  const stuck = attempts >= maxAttempts ? 1 : 0;
  const nextAttemptAt = stuck ? now : computeNextAttemptAt(now, attempts, baseDelaySeconds, maxDelaySeconds);
  db.prepare('UPDATE deposit_events SET status=?, error=?, attempts=?, nextAttemptAt=?, stuck=?, lastErrorAt=? WHERE id=?').run(stuck ? 'stuck' : 'l1_failed', String(err), attempts, nextAttemptAt, stuck, now, eventId);
}

async function withMintRetry<T>(fn: (mint: bigint) => Promise<T>, base: bigint): Promise<T> {
  let mint = base;
  for (let i = 0; i < 3; i++) {
    try {
      return await fn(mint);
    } catch (e) {
      if (i === 2) throw e;
      mint = (mint * 3n) / 2n;
    }
  }
  throw new Error('unreachable');
}

async function processDeposit(row: any) {
  if (!tryAcquireInflight(Number(row.inflightL1 ?? 0))) return;

  const lock = db.prepare('UPDATE deposit_requests SET inflightL1=1 WHERE trackingId=? AND inflightL1=0').run(row.trackingId);
  if (lock.changes === 0) return;

  let eventId = 0;
  try {
    const y = getAddress(row.l1DepositAddressY);

    const ethBal = await publicClient.getBalance({ address: y });
    let erc20Candidate: { tokenAddr: `0x${string}`; bal: bigint } | null = null;
    if (ethBal === 0n) {
      for (const token of supportedTokens) {
        const tokenAddr = getAddress(token.l1Address);
        if (!tokenAllowlist.has(tokenAddr.toLowerCase())) continue;
        const bal = (await publicClient.readContract({ address: tokenAddr, abi: erc20Abi, functionName: 'balanceOf', args: [y] })) as bigint;
        if (bal === 0n) continue;
        erc20Candidate = { tokenAddr, bal };
        break;
      }
    }

    if (ethBal === 0n && !erc20Candidate) return;

    const code = await publicClient.getCode({ address: y });
    let deployTx: `0x${string}` | null = null;
    if (!code || code === '0x') {
      const refundRecipient = process.env.REFUND_RECIPIENT_L2 ?? row.recipientPrividiumAddress;
      deployTx = await walletClient.writeContract({
        address: bridgeConfig.l1.forwarderFactory,
        abi: FORWARDER_FACTORY_L1_ABI,
        functionName: 'deploy',
        args: [row.saltY, bridgeConfig.l1.bridgehub, BigInt(bridgeConfig.l2.chainId), row.l2VaultAddressX, refundRecipient, bridgeConfig.l1.assetRouter, bridgeConfig.l1.nativeTokenVault]
      });
      await publicClient.waitForTransactionReceipt({ hash: deployTx });
      db.prepare('UPDATE deposit_requests SET lastActivityAt=? WHERE trackingId=?').run(Date.now(), row.trackingId);
    }

    if (ethBal > 0n) {
      eventId = createEvent(row.trackingId, 'ETH', ethBal);
      if (deployTx) updateEvent(eventId, 'l1_forwarder_deployed', { l1DeployTxHash: deployTx });
      const sweepTx = await withMintRetry((mint) => walletClient.writeContract({ address: y, abi: STEALTH_FORWARDER_L1_ABI, functionName: 'sweepETH', args: [], value: mint }), defaultMintEth);
      await publicClient.waitForTransactionReceipt({ hash: sweepTx });
      updateEvent(eventId, 'l1_bridging_submitted', { l1BridgeTxHash: sweepTx });
      db.prepare('UPDATE deposit_requests SET lastActivityAt=? WHERE trackingId=?').run(Date.now(), row.trackingId);
      return;
    }

    if (erc20Candidate) {
      eventId = createEvent(row.trackingId, 'ERC20', erc20Candidate.bal, erc20Candidate.tokenAddr);
      if (deployTx) updateEvent(eventId, 'l1_forwarder_deployed', { l1DeployTxHash: deployTx });
      const sweepTx = await withMintRetry(
        (mint) =>
          walletClient.writeContract({
            address: y,
            abi: STEALTH_FORWARDER_L1_ABI,
            functionName: 'sweepERC20',
            args: [erc20Candidate.tokenAddr],
            value: mint
          }),
        defaultMintErc20
      );
      await publicClient.waitForTransactionReceipt({ hash: sweepTx });
      updateEvent(eventId, 'l1_bridging_submitted', { l1BridgeTxHash: sweepTx });
      db.prepare('UPDATE deposit_requests SET lastActivityAt=? WHERE trackingId=?').run(Date.now(), row.trackingId);
      return;
    }
  } catch (e) {
    console.log(`Error processing deposit for trackingId ${row.trackingId}:`, e);
    if (eventId) markEventError(eventId, e);
  } finally {
    db.prepare('UPDATE deposit_requests SET inflightL1=0 WHERE trackingId=?').run(row.trackingId);
  }
}

async function tick() {
  const rows = db
    .prepare('SELECT dr.*, COALESCE(dr.recipientPrividiumAddress, a.recipientPrividiumAddress) AS recipientPrividiumAddress FROM deposit_requests dr JOIN aliases a ON a.aliasKey = dr.aliasKey WHERE dr.isActive = 1 ORDER BY dr.lastActivityAt ASC LIMIT 30')
    .all() as any[];
  for (const row of rows) await processDeposit(row);
}

setInterval(() => void tick(), Number(process.env.RELAYER_POLL_MS ?? 7000));
void tick();
